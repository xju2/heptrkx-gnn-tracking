from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import tensorflow as tf

from graph_nets import modules
from graph_nets import utils_tf
from graph_nets import blocks

import sonnet as snt

NUM_LAYERS = 2    # Hard-code number of layers in the edge/node/global models.
LATENT_SIZE = 128 # Hard-code latent layer sizes for demos.


def make_mlp_model():
  """Instantiates a new MLP, followed by LayerNorm.

  The parameters of each new MLP are not shared with others generated by
  this function.

  Returns:
    A Sonnet module which contains the MLP and LayerNorm.
  """
  return snt.Sequential([
      snt.nets.MLP(
          [LATENT_SIZE] * NUM_LAYERS,
          activation=tf.nn.relu,
          activate_final=True),
  ])

class MLPGraphIndependent(snt.AbstractModule):
  """GraphIndependent with MLP edge, node, and global models."""

  def __init__(self, name="MLPGraphIndependent"):
    super(MLPGraphIndependent, self).__init__(name=name)
    with self._enter_variable_scope():
      self._network = modules.GraphIndependent(
          edge_model_fn=make_mlp_model,
          node_model_fn=make_mlp_model,
          global_model_fn=None)

  def _build(self, inputs):
    return self._network(inputs)


class InteractionNetwork(snt.AbstractModule):

  def __init__(self,
               edge_model_fn,
               node_model_fn,
               reducer=tf.unsorted_segment_sum,
               name="interaction_network"):
    super(InteractionNetwork, self).__init__(name=name)

    with self._enter_variable_scope():
      self._edge_block = blocks.EdgeBlock(
          edge_model_fn=edge_model_fn, use_globals=False)
      self._node_block = blocks.NodeBlock(
          node_model_fn=node_model_fn,
          use_sent_edges=False,
          use_globals=False,
          received_edges_reducer=reducer)

  def _build(self, graph):
    return self._edge_block(self._node_block(graph))
    #return self._node_block(self._edge_block(graph))



class SegmentClassifier(snt.AbstractModule):

  def __init__(self, name="SegmentClassifier"):
    super(SegmentClassifier, self).__init__(name=name)

    self._encoder = MLPGraphIndependent()
    self._core = InteractionNetwork(
        edge_model_fn=make_mlp_model,
        node_model_fn=make_mlp_model
    )
    self._decoder = modules.GraphIndependent(
        edge_model_fn=make_mlp_model,
        node_model_fn=None, global_model_fn=None)

    # Transforms the outputs into appropriate shapes.
    edge_output_size = 1
    edge_fn =lambda: snt.Sequential([
        snt.nets.MLP([LATENT_SIZE, LATENT_SIZE, LATENT_SIZE, edge_output_size],
                     activation=tf.nn.relu, # default is relu
                     name='edge_output'),
        tf.sigmoid])

    with self._enter_variable_scope():
      self._output_transform = modules.GraphIndependent(edge_fn, None, None)

  def _build(self, input_op, num_processing_steps):
    latent = self._encoder(input_op)
    latent0 = latent

    output_ops = []
    for _ in range(num_processing_steps):
        core_input = utils_tf.concat([latent0, latent], axis=1)
        latent = self._core(core_input)

    decoded_op = self._decoder(latent)
    output_ops.append(self._output_transform(decoded_op))
    return output_ops
